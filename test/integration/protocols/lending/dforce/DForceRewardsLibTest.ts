import {SignerWithAddress} from "@nomiclabs/hardhat-ethers/signers";
import {ethers} from "hardhat";
import {TimeUtils} from "../../../../../scripts/utils/TimeUtils";
import {
  DForceRewardsLibFacade,
} from "../../../../../typechain";
import {expect} from "chai";
import {
  IBorrowRewardsPredictionInput,
  ISupplyRewardsStatePoint
} from "../../../../../scripts/integration/helpers/DForceHelper";
import {BigNumber} from "ethers";
import {DeployUtils} from "../../../../../scripts/utils/DeployUtils";
import {MaticAddresses} from "../../../../../scripts/addresses/MaticAddresses";
import {MocksHelper} from "../../../../baseUT/helpers/MocksHelper";

describe("DForceHelper unit tests", () => {
//region Global vars for all tests
  let snapshot: string;
  let snapshotForEach: string;
  let deployer: SignerWithAddress;
  let investor: SignerWithAddress;
  let libFacade: DForceRewardsLibFacade;

//endregion Global vars for all tests

//region before, after
  before(async function () {
    this.timeout(1200000);
    snapshot = await TimeUtils.snapshot();
    const signers = await ethers.getSigners();
    deployer = signers[0];
    investor = signers[0];
    libFacade = await DeployUtils.deployContract(deployer
      , "DForceRewardsLibFacade"
    ) as DForceRewardsLibFacade;
  });

  after(async function () {
    await TimeUtils.rollback(snapshot);
  });

  beforeEach(async function () {
    snapshotForEach = await TimeUtils.snapshot();
  });

  afterEach(async function () {
    await TimeUtils.rollback(snapshotForEach);
  });
//endregion before, after

//region Unit tests
  describe("DForceRewardsLib unit tests", () => {
    describe("supplyRewardAmounts", () => {
      describe("Use data generated by DForceHelper tests ", () => {
        it("should return amount of rewards same to really received", async () => {

          ///////////////////////////////////////////////////////
          // The data below was generated by DForceHelperTest
          // using SupplyBorrowUsingDForce.makeSupplyRewardsTestMinimumTransactions
          // variables supplyPoint and blockUpdateDistributionState
          // see "Test1. Supply, wait, get rewards"
          //
          // In result, the results are checked in two steps:
          // 1) "Test1. Supply, wait, get rewards" checks that DForceHelper.getSupplyRewardsAmount
          //    gives the same amount of rewards as it was actually generated
          // 2) This test checks that DForceRewardsLib.supplyRewardAmounts
          //    generates same amount of rewards as it was actually generated in Test1.
          ///////////////////////////////////////////////////////
          const supplyPoint: ISupplyRewardsStatePoint = {
            blockSupply: BigNumber.from("32290584"),
            beforeSupply: {
              stateIndex: BigNumber.from("215393053582243505"),
              stateBlock: BigNumber.from("32283228"),
              distributionSpeed: BigNumber.from("37268734194063624"),
              totalSupply: BigNumber.from("950110374878895912732010")
            },
            supplyAmount: BigNumber.from("19886232794746960750269")
          };
          const blockUpdateDistributionState = BigNumber.from("32291585");
          const rewardsEarnedActual = BigNumber.from("764823147837685042");
          ///////////////////////////////////////////////////////

          const ret = await libFacade.supplyRewardAmount(
            supplyPoint.blockSupply,
            supplyPoint.beforeSupply.stateIndex,
            supplyPoint.beforeSupply.stateBlock,
            supplyPoint.beforeSupply.distributionSpeed,
            supplyPoint.beforeSupply.totalSupply,
            supplyPoint.supplyAmount,
            blockUpdateDistributionState
          );

          const sret = [
            ret.toString()
          ].join("\n");
          const sexpected = [
            rewardsEarnedActual.toString()
          ].join("\n");

          expect(sret).eq(sexpected);
        });
      });
    });

    describe("borrowRewardAmounts", () => {
      describe("Use data generated by DForceHelper tests ", () => {
        it("should return amount of rewards same to really received", async () => {

          ///////////////////////////////////////////////////////
          // The data below was generated by DForceHelperTest
          // using SupplyBorrowUsingDForce.makeTestBorrowRewardsOnly
          // variables predictData, blockUpdateDistributionState, borrowRateBeforeBorrow, borrowRateAfterBorrow
          // see "Test2. Supply, borrow, wait, claim rewards; borrow rewards only"
          //
          // In result, the results are checked in two steps:
          // 1) "Test2" checks that DForceHelper.predictRewardsStatePointAfterBorrow
          //    gives the same amount of rewards as it was actually generated
          // 2) This test checks that DForceRewardsLib.borrowRewardAmounts
          //    generates same amount of rewards as it was actually generated in Test1.
          ///////////////////////////////////////////////////////
          const rewardsEarnedActual = BigNumber.from("210913823641407222");
          const blockUpdateDistributionState = BigNumber.from("32442504");
          const cashesAndBorrowRates: BigNumber[] = [
            BigNumber.from("188472893545567236961658"),
            BigNumber.from("3239384959"),
            BigNumber.from("198472893545567236961658"),
            BigNumber.from("3214056450")
          ];
          const predictData: IBorrowRewardsPredictionInput = {
            amountToBorrow: BigNumber.from("10000000000000000000000"),
            distributionSpeed: BigNumber.from("15972314654598696"),
            userInterest: BigNumber.from("1008283610150481270"),
            totalReserves: BigNumber.from("685078796128768463280"),
            totalBorrows: BigNumber.from("748769851167139472249361"),
            totalCash: BigNumber.from("188472893545567236961658"),
            accrualBlockNumber: BigNumber.from("32426759"),
            blockNumber: BigNumber.from("32441502"),
            reserveFactor: BigNumber.from("100000000000000000"),
            borrowIndex: BigNumber.from("1008235458586920493"),
            borrowBalanceStored: BigNumber.from("0"),
            stateBlock: BigNumber.from("32426759"),
            stateIndex: BigNumber.from("133007866972213896")
          };
          ///////////////////////////////////////////////////////
          const interestRateModel = await MocksHelper.createDForceInterestRateModelMock(deployer
            , cashesAndBorrowRates[0]
            , cashesAndBorrowRates[1]
            , cashesAndBorrowRates[2]
            , cashesAndBorrowRates[3]
          );

          const ret = await libFacade.borrowRewardAmounts(
            {
              amountToBorrow: predictData.amountToBorrow,
              accrualBlockNumber: predictData.accrualBlockNumber,
              borrowIndex: predictData.borrowIndex,
              borrowBalanceStored: predictData.borrowBalanceStored,
              stateBlock: predictData.stateBlock,
              blockNumber: predictData.blockNumber,
              distributionSpeed: predictData.distributionSpeed,
              userInterest: predictData.userInterest,
              stateIndex: predictData.stateIndex,
              reserveFactor: predictData.reserveFactor,
              totalBorrows: predictData.totalBorrows,
              totalCash: predictData.totalCash,
              totalReserves: predictData.totalReserves,
              interestRateModel: interestRateModel.address
            },
            blockUpdateDistributionState
          );

          const sret = [
            ret.toString()
          ].join("\n");
          const sexpected = [
            rewardsEarnedActual.toString()
          ].join("\n");

          expect(sret).eq(sexpected);
        });
      });
    });
  });
//endregion Unit tests

});